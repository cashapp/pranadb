package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/alecthomas/kong"
	"github.com/iancoleman/strcase"
	"golang.org/x/tools/go/packages"
)

const controlPrefix = "//go2proto:"

type enum struct {
	Name  string
	Value int
}

var transcodeTemplate = template.Must(template.New("transcode").
	Funcs(template.FuncMap{
		"Fields":        messageFields,
		"PackageDecl":   func(s string) string { return path.Base(s) },
		"CastToProto":   castToProto,
		"CastFromProto": castFromProto,
	}).
	Parse(`// Code generated by go2proto. DO NOT EDIT.

package {{.SourcePackage|PackageDecl}}

import prototypes "{{.GoPackage}}"

{{range $k, $v := .Enums}}
func {{$k}}FromProto(v prototypes.{{$k}}) {{$k}} { return {{$k}}(v) }
func (v {{$k}}) ToProto() prototypes.{{$k}} { return prototypes.{{$k}}(v) }
{{end}}
{{range $msg := .Messages}}
func {{$msg.Name}}FromProto(m *prototypes.{{$msg.Name}}) *{{$msg.Name}} { 
	return &{{$msg.Name}}{
{{- range .|Fields}}
		{{.Name}}: {{.|CastFromProto}},
{{- end}}
	}
}
func (m *{{$msg.Name}}) ToProto() *prototypes.{{$msg.Name}} {
	return &prototypes.{{$msg.Name}}{
{{- range .|Fields}}
		{{.Name}}: {{.|CastToProto}},
{{- end}}
	}
{{end}}
}
`))
var protoTemplate = template.Must(template.New("proto").
	Funcs(template.FuncMap{
		"OrderedEnums": func(values map[string]int) (out []enum) {
			out = make([]enum, 0, len(values))
			for k, v := range values {
				out = append(out, enum{k, v})
			}
			sort.Slice(out, func(i, j int) bool {
				return out[i].Value < out[j].Value
			})
			return
		},
		"Fields": messageFields,
		"EnumName": func(s string) string {
			return strcase.ToScreamingSnake(s)
		},
		"FieldName": func(s string) string {
			return strcase.ToSnake(s)
		},
		"FieldID": func(i int) int {
			return i + 1
		},
		"FieldType": fieldType,
	}).
	Parse(`// Code generated by go2proto. DO NOT EDIT.
	
syntax = "proto3";

package {{.Package}};

option go_package = "{{.GoPackage}}";
{{range $k, $v := .Enums}}
enum {{$k}} {
{{- range $enum := (.|OrderedEnums)}}
  {{.Name|EnumName}} = {{.Value}};
{{- end}}
}
{{end -}}
{{range .Messages}}
message {{.Name}} {
{{- range $id, $field := .|Fields}}
  {{$field.Type|FieldType}} {{$field.Name|FieldName}} = {{$id|FieldID}};
{{- end}}
}
{{end}}
`))

type protobufState struct {
	Package       string
	SourcePackage string
	GoPackage     string
	Enums         map[string]map[string]int
	Messages      []*types.TypeName
	Comments      map[string]string
}

var cli struct {
	Package string `help:"Go package to generate .proto files from." required:"" arg:""`
}

func main() {
	kctx := kong.Parse(&cli)
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedTypesInfo | packages.NeedSyntax,
	}, cli.Package)
	kctx.FatalIfErrorf(err)

	state := &protobufState{
		Package:       "squareup.cash.pranadb",
		SourcePackage: "github.com/cashapp/pranadb/common",
		GoPackage:     "github.com/cashapp/pranadb/protos/squareup/cash/pranadb",
		Enums:         map[string]map[string]int{},
		Comments:      map[string]string{},
	}
	for _, pkg := range pkgs {
		scope := pkg.Types.Scope()
		// Collect messages and enums.
		for _, name := range scope.Names() {
			sym := scope.Lookup(name)
			if !sym.Exported() {
				continue
			}
			updateProtoTypes(state, sym, pkg)
		}
		// Compute enum values.
		for _, file := range pkg.Syntax {
			collectEnumValues(file, state)
		}
	}

	// Write the proto file.
	err = protoTemplate.Execute(os.Stdout, state)
	kctx.FatalIfErrorf(err)

	// Write the proto file.
	err = transcodeTemplate.Execute(os.Stdout, state)
	kctx.FatalIfErrorf(err)
}

func collectEnumValues(file *ast.File, state *protobufState) {
	var (
		iota ast.Expr
		enum map[string]int
	)
	for _, decl := range file.Decls {
		if decl, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range decl.Specs {
				if value, ok := spec.(*ast.ValueSpec); ok {
					// Possibly start of iota?
					if value.Type != nil {
						typ := value.Type.(fmt.Stringer).String()
						enum, ok = state.Enums[typ]
						if ok {
							iota = value.Values[0]
							enum[value.Names[0].Name] = eval(len(enum), iota)
						} else {
							enum = nil
						}
					} else if enum != nil {
						enum[value.Names[0].Name] = eval(len(enum), iota)
					}
				} else {
					enum = nil
				}
			}
		} else {
			enum = nil
		}
	}
}

// Evaluate a constant expression.
func eval(enums int, expr ast.Expr) int {
	switch expr := expr.(type) {
	case *ast.Ident:
		if expr.Name == "iota" {
			return enums
		} else {
			panic("only iota is supported")
		}

	case *ast.BinaryExpr:
		left := eval(enums, expr.X)
		right := eval(enums, expr.Y)
		switch expr.Op.String() {
		case "+":
			return left + right
		case "-":
			return left - right
		case "*":
			return left * right
		case "/":
			return left / right
		default:
			panic("only basic arithmetic is supported")
		}

	case *ast.BasicLit:
		switch expr.Kind.String() {
		case "INT":
			value, _ := strconv.ParseInt(expr.Value, 0, 64)
			return int(value)
		default:
			panic("only integers are supported")
		}

	default:
		panic(fmt.Sprintf("%T", expr))
	}
	return 0
}

// Search the syntax tree for "//go2proto:X" comment directives prior to the
// definition of "sym" and collect those tagged types into "state".
func updateProtoTypes(state *protobufState, sym types.Object, pkg *packages.Package) {
	tpos := pkg.Fset.Position(sym.Pos())
	for _, file := range pkg.Syntax {
		fpos := pkg.Fset.Position(file.Pos())
		if fpos.Filename != tpos.Filename {
			continue
		}
		for _, comment := range file.Comments {
			cpos := pkg.Fset.Position(comment.End())
			if tpos.Line-1 == cpos.Line {
				for _, line := range comment.List {
					if strings.HasPrefix(line.Text, controlPrefix) {
						directive := line.Text[len(controlPrefix):]
						switch directive {
						case "enum":
							state.Enums[sym.Name()] = map[string]int{}
							return

						case "message":
							typ, ok := sym.(*types.TypeName)
							if !ok {
								panic(sym.String() + " must be a struct")
							}
							_, ok = typ.Type().Underlying().(*types.Struct)
							if !ok {
								panic(sym.String() + " must be a struct")
							}
							state.Messages = append(state.Messages, typ)

						default:
							panic("??")
						}
					}
				}
			}
		}
	}
}

func fieldType(t types.Type) string {
	switch t := t.(type) {
	case *types.Basic:
		switch t.Name() {
		case "int":
			return "int64"

		case "uint":
			return "uint64"

		case "uint32", "int32", "uint64", "int64", "string":
			return t.Name()

		case "uint8", "uint16":
			return "uint32"

		case "int8", "int16":
			return "int32"

		default:
			panic(t.Name())
		}

	case *types.Pointer:
		return fieldType(t.Elem())

	case *types.Slice:
		return "repeated " + fieldType(t.Elem())

	case *types.Map:
		return fmt.Sprintf("map<%s, %s>", fieldType(t.Key()), fieldType(t.Elem()))

	case *types.Interface:
		if t.Empty() {
			return "google.protobuf.Any"
		}
		panic(fmt.Sprintf("%T", t))

	case *types.Named:
		switch t.String() {
		case "time.Time":
			return "google.protobuf.Time"

		case "time.Duration":
			return "google.protobuf.Duration"
		}
		return t.Obj().Name()

	default:
		panic(fmt.Sprintf("%T", t))
	}
}

func messageFields(sym *types.TypeName) (out []*types.Var) {
	strct := sym.Type().Underlying().(*types.Struct)
	for i := 0; i < strct.NumFields(); i++ {
		field := strct.Field(i)
		out = append(out, field)
	}
	return
}

func castToProto(f *types.Var) string {
	switch t := f.Type().(type) {
	case *types.Basic:
		switch t.Name() {
		case "uint32", "int32", "uint64", "int64", "string":
			return "m." + f.Name()

		default:
			return fmt.Sprintf("%s(m.%s)", fieldType(t), f.Name())
		}

	case *types.Named:
		return "m." + f.Name() + ".ToProto()"

	default:
		panic(f.String())
	}
}

func castFromProto(f *types.Var) string {
	switch t := f.Type().(type) {
	case *types.Basic:
		switch t.Name() {
		case "uint32", "int32", "uint64", "int64", "string":
			return "m." + f.Name()

		default:
			return fmt.Sprintf("%s(m.%s)", fieldType(t), f.Name())
		}

	case *types.Named:
		return fmt.Sprintf("%sFromProto(m.%s)", t.Obj().Name(), f.Name())

	default:
		panic(f.String())
	}
}
